#!/bin/bash

# Скрипт для удаления комментариев из всех .kt файлов
# в текущей директории и всех ее поддиректориях.
# Удаляет комментарии, начинающиеся с //
# Удаляет многострочные комментарии вида /** ... */
# Если комментарий занимает всю строку (возможно, с пробелами в начале),
# то удаляется вся строка, включая символ новой строки.
# Если комментарий находится в строке после кода, удаляется только сам комментарий.

# Счетчик обработанных файлов
processed_files=0
# Счетчик найденных файлов
found_files=0

# AWK скрипт для удаления комментариев
# Он обрабатывает как //, так и /** ... */ комментарии.
# Переменная in_block отслеживает, находимся ли мы внутри многострочного комментария.
AWK_SCRIPT='
BEGIN {
    in_block = 0; # 0 - не в блоке, 1 - в блоке /** ... */
}
{
    line = $0;
    outline = "";
    i = 1;
    len = length(line);

    while (i <= len) {
        if (in_block) {
            # Мы внутри многострочного комментария /** ... */
            # Ищем конец блока "*/"
            if (i + 1 <= len && substr(line, i, 2) == "*/") {
                in_block = 0; # Выходим из блока
                i += 2;       # Пропускаем "*/"
            } else {
                i++;          # Пропускаем символ внутри блока комментария
            }
        } else {
            # Мы не в многострочном комментарии
            # Ищем начало многострочного комментария "/**"
            if (i + 2 <= len && substr(line, i, 3) == "/**") {
                in_block = 1; # Входим в блок
                i += 3;       # Пропускаем "/**"
            }
            # Ищем начало однострочного комментария "//"
            else if (i + 1 <= len && substr(line, i, 2) == "//") {
                # Однострочный комментарий, остаток строки игнорируется
                break; # Выходим из цикла while для текущей строки
            }
            # Не комментарий, добавляем символ к выходной строке
            else {
                outline = outline substr(line, i, 1);
                i++;
            }
        }
    }

    # После обработки строки, если outline не пустая и не состоит только из пробелов, печатаем ее.
    # Это удаляет строки, которые стали пустыми после удаления комментариев.
    if (outline !~ /^[ \t]*$/) {
        print outline;
    }
}
'

# Используем find для поиска всех .kt файлов в текущей директории (.) и ее поддиректориях.
find . -type f -name "*.kt" -print0 | while IFS= read -r -d $'\0' FILENAME; do
  ((found_files++))
  echo "Обработка файла: $FILENAME"

  processed_this_file=false
  # Проверяем, доступен ли GNU awk для редактирования на месте (-i inplace)
  if awk --version 2>/dev/null | grep -q "GNU Awk"; then
    if awk -i inplace "$AWK_SCRIPT" "$FILENAME"; then
      processed_this_file=true
    else
      echo "Ошибка: awk -i inplace не удалось обработать $FILENAME."
    fi
  else
    # Используем временный файл для других версий awk
    TMPFILE=$(mktemp)
    # Проверка, удалось ли создать временный файл
    if [ -z "$TMPFILE" ] || [ ! -f "$TMPFILE" ]; then
        echo "Ошибка: Не удалось создать временный файл для $FILENAME."
    else
        if awk "$AWK_SCRIPT" "$FILENAME" > "$TMPFILE"; then
            if mv "$TMPFILE" "$FILENAME"; then
                processed_this_file=true
            else
                echo "Ошибка: Не удалось переместить временный файл в $FILENAME."
                rm -f "$TMPFILE" # Попытка удалить временный файл
            fi
        else
            echo "Ошибка обработки файла $FILENAME с помощью awk (вывод во временный файл)."
            rm -f "$TMPFILE" # Попытка удалить временный файл
        fi
    fi
  fi

  if [ "$processed_this_file" = true ]; then
    ((processed_files++))
  fi
done

if [ "$found_files" -eq 0 ]; then
  echo "Файлы с расширением .kt не найдены в текущей директории и ее поддиректориях."
else
  echo "Обработка завершена. Удалены комментарии из $processed_files файла(ов) из $found_files найденных."
fi
